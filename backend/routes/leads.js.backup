import express from 'express';
const router = express.Router();
import { auth, requireCommercial, requireAdmin } from '../middleware/auth.js';
import { validate, schemas } from '../middleware/validation.js';
import Lead from '../models/Lead.js';
import User from '../models/User.js';

// @route   POST api/leads
// @desc    Create a new lead
// @access  Private (Commercial or Admin)
router.post('/', [auth, requireCommercial, validate(schemas.createLead)], async (req, res) => {
  try {
    const { nom, email, telephone, adresse, ville, entreprise, source } = req.body;

    const newLead = new Lead({
      nom,
      email,
      telephone,
      adresse,
      ville,
      entreprise,
      source,
      creePar: req.user.id,
      assigneA: req.user.id, // Assign to self by default
    });

    const lead = await newLead.save();
    res.status(201).json(lead);
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Erreur du serveur');
  }
});

// @route   GET api/leads
// @desc    Get all leads with pagination and filtering
// @access  Private (Commercial or Admin)
router.get('/', [auth, requireCommercial], async (req, res) => {
  try {
    const { page = 1, limit = 10, statut, source, search } = req.query;
    const query = {};

    // Role-based access: Admins see all, commercials see their own or unassigned
    if (req.user.role !== 'admin') {
        query.$or = [
            { assigneA: req.user.id },
            { assigneA: null }
        ];
    }

    if (statut) query.statut = statut;
    if (source) query.source = source;
    if (search) {
      query.$or = [
        { nom: { $regex: search, $options: 'i' } },
        { email: { $regex: search, $options: 'i' } },
        { entreprise: { $regex: search, $options: 'i' } },
      ];
    }

    const leads = await Lead.find(query)
      .populate('creePar', 'nom email')
      .populate('assigneA', 'nom email')
      .limit(limit * 1)
      .skip((page - 1) * limit)
      .sort({ createdAt: -1 });
      
    const count = await Lead.countDocuments(query);

    res.json({
      leads,
      totalPages: Math.ceil(count / limit),
      currentPage: parseInt(page),
      totalLeads: count
    });
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Erreur du serveur');
  }
});

// @route   GET api/leads/:id
// @desc    Get a single lead by ID
// @access  Private (Commercial or Admin)
router.get('/:id', [auth, requireCommercial], async (req, res) => {
  try {
    const lead = await Lead.findById(req.params.id)
      .populate('creePar', 'nom email')
      .populate('assigneA', 'nom email');

    if (!lead) {
      return res.status(404).json({ message: 'Lead non trouvé' });
    }

    // Security check: ensure commercial can only access their leads
    if (req.user.role !== 'admin' && lead.assigneA && lead.assigneA.toString() !== req.user.id) {
        return res.status(403).json({ message: 'Accès non autorisé à ce lead.' });
    }

    res.json(lead);
  } catch (err) {
    console.error(err.message);
    if (err.kind === 'ObjectId') {
        return res.status(404).json({ message: 'Lead non trouvé (ID invalide)' });
    }
    res.status(500).send('Erreur du serveur');
  }
});

// @route   PUT api/leads/:id/status
// @desc    Update lead status
// @access  Private (Commercial or Admin)
router.put('/:id/status', [auth, requireCommercial], async (req, res) => {
    try {
        const { statut } = req.body;
        if (!['nouveau', 'contacté', 'qualifié', 'perdu', 'gagné'].includes(statut)) {
            return res.status(400).json({ message: 'Statut non valide.' });
        }

        const lead = await Lead.findById(req.params.id);
        if (!lead) {
            return res.status(404).json({ message: 'Lead non trouvé' });
        }

        if (req.user.role !== 'admin' && lead.assigneA && lead.assigneA.toString() !== req.user.id) {
            return res.status(403).json({ message: 'Accès non autorisé' });
        }

        lead.statut = statut;
        await lead.save();
        
        res.json(lead);
    } catch (err) {
        console.error(err.message);
        res.status(500).send('Erreur du serveur');
    }
});

// @route   PUT api/leads/:id/assign
// @desc    Assign a lead to a user
// @access  Private (Admin)
router.put('/:id/assign', [auth, requireAdmin], async (req, res) => {
    try {
        const { userId } = req.body;

        const userToAssign = await User.findById(userId);
        if (!userToAssign || (userToAssign.role !== 'commercial' && userToAssign.role !== 'admin')) {
            return res.status(400).json({ message: 'Utilisateur invalide ou non autorisé pour l\'assignation.' });
        }

        const lead = await Lead.findByIdAndUpdate(
            req.params.id,
            { assigneA: userId },
            { new: true }
        ).populate('assigneA', 'nom email');

        if (!lead) {
            return res.status(404).json({ message: 'Lead non trouvé' });
        }
        res.json(lead);
    } catch (err) {
        console.error(err.message);
        res.status(500).send('Erreur du serveur');
    }
});

// @route   DELETE api/leads/:id
// @desc    Delete a lead
// @access  Private (Admin)
router.delete('/:id', [auth, requireAdmin], async (req, res) => {
    try {
        const lead = await Lead.findById(req.params.id);
        if (!lead) {
            return res.status(404).json({ message: 'Lead non trouvé' });
        }

        await lead.remove();

        res.json({ message: 'Lead supprimé avec succès.' });
    } catch (err) {
        console.error(err.message);
        res.status(500).send('Erreur du serveur');
    }
});


export default router;
